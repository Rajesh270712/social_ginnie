{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions, for situations in which at least one part of the expression is async.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See\n * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nfunction _asyncOptionalChain(_x) {\n  return _asyncOptionalChain2.apply(this, arguments);\n} // Sucrase version:\n// async function _asyncOptionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = await fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = await fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\nfunction _asyncOptionalChain2() {\n  _asyncOptionalChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ops) {\n    var lastAccessLHS, value, i, op, fn;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          lastAccessLHS = undefined;\n          value = ops[0];\n          i = 1;\n        case 3:\n          if (!(i < ops.length)) {\n            _context.next = 23;\n            break;\n          }\n          op = ops[i];\n          fn = ops[i + 1];\n          i += 2;\n          // by checking for loose equality to `null`, we catch both `null` and `undefined`\n          if (!((op === 'optionalAccess' || op === 'optionalCall') && value == null)) {\n            _context.next = 9;\n            break;\n          }\n          return _context.abrupt(\"return\");\n        case 9:\n          if (!(op === 'access' || op === 'optionalAccess')) {\n            _context.next = 16;\n            break;\n          }\n          lastAccessLHS = value;\n          _context.next = 13;\n          return fn(value);\n        case 13:\n          value = _context.sent;\n          _context.next = 21;\n          break;\n        case 16:\n          if (!(op === 'call' || op === 'optionalCall')) {\n            _context.next = 21;\n            break;\n          }\n          _context.next = 19;\n          return fn(function () {\n            var _value;\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            return (_value = value).call.apply(_value, [lastAccessLHS].concat(args));\n          });\n        case 19:\n          value = _context.sent;\n          lastAccessLHS = undefined;\n        case 21:\n          _context.next = 3;\n          break;\n        case 23:\n          return _context.abrupt(\"return\", value);\n        case 24:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _asyncOptionalChain2.apply(this, arguments);\n}\nexport { _asyncOptionalChain };","map":{"version":3,"mappings":";;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA,SAUAA;EAAA;AAAA,EAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;EAAA,kFA7CA;IAAA;IAAA;MAAA;QAAA;UACAC;UACAC;UACAC;QAAA;UAAA,MACAA;YAAA;YAAA;UAAA;UACAC;UACAC;UACAF;UACA;UAAA,MACA;YAAA;YAAA;UAAA;UAAA;QAAA;UAAA,MAIAC;YAAA;YAAA;UAAA;UACAH;UAAA;UAAA,OACAI;QAAA;UAAAH;UAAA;UAAA;QAAA;UAAA,MACAE;YAAA;YAAA;UAAA;UAAA;UAAA,OACAC;YAAA;YAAA;cAAAC;YAAA;YAAA;UAAA;QAAA;UAAAJ;UACAD;QAAA;UAAA;UAAA;QAAA;UAAA,iCAGAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACA;EAAA;AAAA","names":["_asyncOptionalChain","lastAccessLHS","value","i","op","fn","args"],"sources":["/Users/rajeshbagul/code/ai-hackathon/node_modules/@sentry/src/buildPolyfills/_asyncOptionalChain.ts"],"sourcesContent":["import type { GenericFunction } from './types';\n\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions, for situations in which at least one part of the expression is async.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See\n * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nexport async function _asyncOptionalChain(ops: unknown[]): Promise<unknown> {\n  let lastAccessLHS: unknown = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i] as string;\n    const fn = ops[i + 1] as (intermediateValue: unknown) => Promise<unknown>;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = await fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = await fn((...args: unknown[]) => (value as GenericFunction).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version:\n// async function _asyncOptionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = await fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = await fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
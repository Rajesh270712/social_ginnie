{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _assertThisInitialized from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _classCallCheck from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rajeshbagul/code/ai-hackathon/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { logger, timestampWithMs } from '@sentry/utils';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\nvar DEFAULT_IDLE_TIMEOUT = 1000;\nvar DEFAULT_FINAL_TIMEOUT = 30000;\nvar DEFAULT_HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nvar IdleTransactionSpanRecorder = /*#__PURE__*/function (_SpanRecorder) {\n  _inherits(IdleTransactionSpanRecorder, _SpanRecorder);\n  var _super = _createSuper(IdleTransactionSpanRecorder);\n  function IdleTransactionSpanRecorder(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    var _this;\n    _classCallCheck(this, IdleTransactionSpanRecorder);\n    _this = _super.call(this, maxlen);\n    _this._pushActivity = _pushActivity;\n    _this._popActivity = _popActivity;\n    _this.transactionSpanId = transactionSpanId;\n    return _this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  _createClass(IdleTransactionSpanRecorder, [{\n    key: \"add\",\n    value: function add(span) {\n      var _this2 = this;\n      // We should make sure we do not push and pop activities for\n      // the transaction that this span recorder belongs to.\n      if (span.spanId !== this.transactionSpanId) {\n        // We patch span.finish() to pop an activity after setting an endTimestamp.\n        span.finish = function (endTimestamp) {\n          span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n          _this2._popActivity(span.spanId);\n        };\n\n        // We should only push new activities if the span does not have an end timestamp.\n        if (span.endTimestamp === undefined) {\n          this._pushActivity(span.spanId);\n        }\n      }\n      _get(_getPrototypeOf(IdleTransactionSpanRecorder.prototype), \"add\", this).call(this, span);\n    }\n  }]);\n  return IdleTransactionSpanRecorder;\n}(SpanRecorder);\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nvar IdleTransaction = /*#__PURE__*/function (_Transaction) {\n  _inherits(IdleTransaction, _Transaction);\n  var _super2 = _createSuper(IdleTransaction);\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n\n  function IdleTransaction(transactionContext, _idleHub) {\n    var _this3;\n    var _idleTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_IDLE_TIMEOUT;\n    var _finalTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_FINAL_TIMEOUT;\n    var _heartbeatInterval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_HEARTBEAT_INTERVAL;\n    var _onScope = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    _classCallCheck(this, IdleTransaction);\n    _this3 = _super2.call(this, transactionContext, _idleHub);\n    _this3._idleHub = _idleHub;\n    _this3._idleTimeout = _idleTimeout;\n    _this3._finalTimeout = _finalTimeout;\n    _this3._heartbeatInterval = _heartbeatInterval;\n    _this3._onScope = _onScope;\n    IdleTransaction.prototype.__init.call(_assertThisInitialized(_this3));\n    IdleTransaction.prototype.__init2.call(_assertThisInitialized(_this3));\n    IdleTransaction.prototype.__init3.call(_assertThisInitialized(_this3));\n    IdleTransaction.prototype.__init4.call(_assertThisInitialized(_this3));\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"Setting idle transaction on scope. Span ID: \".concat(_this3.spanId));\n      _idleHub.configureScope(function (scope) {\n        return scope.setSpan(_assertThisInitialized(_this3));\n      });\n    }\n    _this3._startIdleTimeout();\n    setTimeout(function () {\n      if (!_this3._finished) {\n        _this3.setStatus('deadline_exceeded');\n        _this3.finish();\n      }\n    }, _this3._finalTimeout);\n    return _this3;\n  }\n\n  /** {@inheritDoc} */\n  _createClass(IdleTransaction, [{\n    key: \"__init\",\n    value:\n    // Activities store a list of active spans\n    function __init() {\n      this.activities = {};\n    }\n\n    // Track state of activities in previous heartbeat\n\n    // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  }, {\n    key: \"__init2\",\n    value: function __init2() {\n      this._heartbeatCounter = 0;\n    }\n\n    // We should not use heartbeat if we finished a transaction\n  }, {\n    key: \"__init3\",\n    value: function __init3() {\n      this._finished = false;\n    }\n  }, {\n    key: \"__init4\",\n    value: function __init4() {\n      this._beforeFinishCallbacks = [];\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var _this4 = this;\n      var endTimestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : timestampWithMs();\n      this._finished = true;\n      this.activities = {};\n      if (this.spanRecorder) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n        var _iterator = _createForOfIteratorHelper(this._beforeFinishCallbacks),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var callback = _step.value;\n            callback(this, endTimestamp);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.spanRecorder.spans = this.spanRecorder.spans.filter(function (span) {\n          // If we are dealing with the transaction itself, we just return it\n          if (span.spanId === _this4.spanId) {\n            return true;\n          }\n\n          // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n          if (!span.endTimestamp) {\n            span.endTimestamp = endTimestamp;\n            span.setStatus('cancelled');\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n          }\n          var keepSpan = span.startTimestamp < endTimestamp;\n          if (!keepSpan) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));\n          }\n          return keepSpan;\n        });\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] flushing IdleTransaction');\n      } else {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] No active IdleTransaction');\n      }\n\n      // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n      if (this._onScope) {\n        clearActiveTransaction(this._idleHub);\n      }\n      return _get(_getPrototypeOf(IdleTransaction.prototype), \"finish\", this).call(this, endTimestamp);\n    }\n\n    /**\n     * Register a callback function that gets excecuted before the transaction finishes.\n     * Useful for cleanup or if you want to add any additional spans based on current context.\n     *\n     * This is exposed because users have no other way of running something before an idle transaction\n     * finishes.\n     */\n  }, {\n    key: \"registerBeforeFinishCallback\",\n    value: function registerBeforeFinishCallback(callback) {\n      this._beforeFinishCallbacks.push(callback);\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"initSpanRecorder\",\n    value: function initSpanRecorder(maxlen) {\n      var _this5 = this;\n      if (!this.spanRecorder) {\n        var pushActivity = function pushActivity(id) {\n          if (_this5._finished) {\n            return;\n          }\n          _this5._pushActivity(id);\n        };\n        var popActivity = function popActivity(id) {\n          if (_this5._finished) {\n            return;\n          }\n          _this5._popActivity(id);\n        };\n        this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n        // Start heartbeat so that transactions do not run forever.\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Starting heartbeat');\n        this._pingHeartbeat();\n      }\n      this.spanRecorder.add(this);\n    }\n\n    /**\n     * Cancels the existing idletimeout, if there is one\n     */\n  }, {\n    key: \"_cancelIdleTimeout\",\n    value: function _cancelIdleTimeout() {\n      if (this._idleTimeoutID) {\n        clearTimeout(this._idleTimeoutID);\n        this._idleTimeoutID = undefined;\n      }\n    }\n\n    /**\n     * Creates an idletimeout\n     */\n  }, {\n    key: \"_startIdleTimeout\",\n    value: function _startIdleTimeout(endTimestamp) {\n      var _this6 = this;\n      this._cancelIdleTimeout();\n      this._idleTimeoutID = setTimeout(function () {\n        if (!_this6._finished && Object.keys(_this6.activities).length === 0) {\n          _this6.finish(endTimestamp);\n        }\n      }, this._idleTimeout);\n    }\n\n    /**\n     * Start tracking a specific activity.\n     * @param spanId The span id that represents the activity\n     */\n  }, {\n    key: \"_pushActivity\",\n    value: function _pushActivity(spanId) {\n      this._cancelIdleTimeout();\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"[Tracing] pushActivity: \".concat(spanId));\n      this.activities[spanId] = true;\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    /**\n     * Remove an activity from usage\n     * @param spanId The span id that represents the activity\n     */\n  }, {\n    key: \"_popActivity\",\n    value: function _popActivity(spanId) {\n      if (this.activities[spanId]) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"[Tracing] popActivity \".concat(spanId));\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete this.activities[spanId];\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n      }\n      if (Object.keys(this.activities).length === 0) {\n        // We need to add the timeout here to have the real endtimestamp of the transaction\n        // Remember timestampWithMs is in seconds, timeout is in ms\n        var endTimestamp = timestampWithMs() + this._idleTimeout / 1000;\n        this._startIdleTimeout(endTimestamp);\n      }\n    }\n\n    /**\n     * Checks when entries of this.activities are not changing for 3 beats.\n     * If this occurs we finish the transaction.\n     */\n  }, {\n    key: \"_beat\",\n    value: function _beat() {\n      // We should not be running heartbeat if the idle transaction is finished.\n      if (this._finished) {\n        return;\n      }\n      var heartbeatString = Object.keys(this.activities).join('');\n      if (heartbeatString === this._prevHeartbeatString) {\n        this._heartbeatCounter++;\n      } else {\n        this._heartbeatCounter = 1;\n      }\n      this._prevHeartbeatString = heartbeatString;\n      if (this._heartbeatCounter >= 3) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      } else {\n        this._pingHeartbeat();\n      }\n    }\n\n    /**\n     * Pings the heartbeat\n     */\n  }, {\n    key: \"_pingHeartbeat\",\n    value: function _pingHeartbeat() {\n      var _this7 = this;\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"pinging Heartbeat -> current counter: \".concat(this._heartbeatCounter));\n      setTimeout(function () {\n        _this7._beat();\n      }, this._heartbeatInterval);\n    }\n  }]);\n  return IdleTransaction;\n}(Transaction);\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub) {\n  var scope = hub.getScope();\n  if (scope) {\n    var transaction = scope.getTransaction();\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\nexport { DEFAULT_FINAL_TIMEOUT, DEFAULT_HEARTBEAT_INTERVAL, DEFAULT_IDLE_TIMEOUT, IdleTransaction, IdleTransactionSpanRecorder };","map":{"version":3,"mappings":";;;;;;;;;;;AASA;AACA;AACA;;AAEA;AACA;AACA;AAFA,IAGAA;EAAA;EAAA;EACA,qCACAC,eACAC,cACAC,mBACAC,QACA;IAAA;IAAA;IACA;IAAA;IAAA;IAAA;IACA;EAAA;;EAEA;AACA;AACA;EAFA;IAAA;IAAA,OAGA;MAAA;MACA;MACA;MACA;QACA;QACAC;UACAA;UACA;QACA;;QAEA;QACA;UACA;QACA;MACA;MAEA;IACA;EAAA;EAAA;AAAA,EA9BAC;AAmCA;AACA;AACA;AACA;AACA;AAJA,IAKAC;EAAA;EAAA;EAeA;AACA;AACA;;EAGA,yBACAC,oBACAC,UAaA;IAAA;IAAA,IARAC;IAAA,IAIAC;IAAA,IACAC;IAAA,IAEAC;IAAA;IAEA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAAN;IAAAA;IAAAA;IAAAA;IAEA;MACA;MACAO;;MAEA;MACA;MACA;MACAL;QAAA;MAAA;IACA;IAEA;IACAM;MACA;QACA;QACA;MACA;IACA;IAAA;EACA;;EAEA;EAAA;IAAA;IAAA;IAxDA;IACA;MAAA;IAAA;;IAEA;;IAGA;EAAA;IAAA;IAAA,OACA;MAAA;IAAA;;IAEA;EAAA;IAAA;IAAA,OACA;MAAA;IAAA;EAAA;IAAA;IAAA,OAEA;MAAA;IAAA;EAAA;IAAA;IAAA,OA6CA;MAAA;MAAA;MACA;MACA;MAEA;QACA,iEACAC;QAAA,2CAEA;UAAA;QAAA;UAAA;YAAA;YACAC;UACA;QAAA;UAAA;QAAA;UAAA;QAAA;QAEA;UACA;UACA;YACA;UACA;;UAEA;UACA;YACAZ;YACAA;YACA,iEACAW;UACA;UAEA;UACA;YACA,iEACAA,WACA,8EACAE,mCACA;UACA;UACA;QACA;QAEA;MACA;QACA;MACA;;MAEA;MACA;QACAJ;MACA;MAEA;IACA;;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANA;IAAA;IAAA,OAOA;MACA;IACA;;IAEA;AACA;AACA;EAFA;IAAA;IAAA,OAGA;MAAA;MACA;QACA;UACA;YACA;UACA;UACA;QACA;QACA;UACA;YACA;UACA;UACA;QACA;QAEA;;QAEA;QACA;QACA;MACA;MACA;IACA;;IAEA;AACA;AACA;EAFA;IAAA;IAAA,OAGA;MACA;QACAK;QACA;MACA;IACA;;IAEA;AACA;AACA;EAFA;IAAA;IAAA,OAGA;MAAA;MACA;MACA;QACA;UACA;QACA;MACA;IACA;;IAEA;AACA;AACA;AACA;EAHA;IAAA;IAAA,OAIA;MACA;MACA;MACA;MACA;IACA;;IAEA;AACA;AACA;AACA;EAHA;IAAA;IAAA,OAIA;MACA;QACA;QACA;QACA;QACA;MACA;MAEA;QACA;QACA;QACA;QACA;MACA;IACA;;IAEA;AACA;AACA;AACA;EAHA;IAAA;IAAA,OAIA;MACA;MACA;QACA;MACA;MAEA;MAEA;QACA;MACA;QACA;MACA;MAEA;MAEA;QACA;QACA;QACA;MACA;QACA;MACA;IACA;;IAEA;AACA;AACA;EAFA;IAAA;IAAA,OAGA;MAAA;MACA;MACAJ;QACA;MACA;IACA;EAAA;EAAA;AAAA,EA5OAK;AA+OA;AACA;AACA;AACA;EACA;EACA;IACA;IACA;MACAC;IACA;EACA;AACA","names":["IdleTransactionSpanRecorder","_pushActivity","_popActivity","transactionSpanId","maxlen","span","SpanRecorder","IdleTransaction","transactionContext","_idleHub","_idleTimeout","_finalTimeout","_heartbeatInterval","_onScope","clearActiveTransaction","setTimeout","logger","callback","JSON","clearTimeout","Transaction","scope"],"sources":["/Users/rajeshbagul/code/ai-hackathon/node_modules/src/idletransaction.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Hub } from '@sentry/core';\nimport type { TransactionContext } from '@sentry/types';\nimport { logger, timestampWithMs } from '@sentry/utils';\n\nimport type { Span } from './span';\nimport { SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const DEFAULT_IDLE_TIMEOUT = 1000;\nexport const DEFAULT_FINAL_TIMEOUT = 30000;\nexport const DEFAULT_HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string,\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  private _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n    private readonly _idleTimeout: number = DEFAULT_IDLE_TIMEOUT,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n    private readonly _finalTimeout: number = DEFAULT_FINAL_TIMEOUT,\n    private readonly _heartbeatInterval: number = DEFAULT_HEARTBEAT_INTERVAL,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      __DEBUG_BUILD__ && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._startIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampWithMs()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      __DEBUG_BUILD__ &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          __DEBUG_BUILD__ &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          __DEBUG_BUILD__ &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      __DEBUG_BUILD__ && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      __DEBUG_BUILD__ && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      __DEBUG_BUILD__ && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idletimeout, if there is one\n   */\n  private _cancelIdleTimeout(): void {\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Creates an idletimeout\n   */\n  private _startIdleTimeout(endTimestamp?: Parameters<IdleTransaction['finish']>[0]): void {\n    this._cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    this._cancelIdleTimeout();\n    __DEBUG_BUILD__ && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      __DEBUG_BUILD__ && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      const endTimestamp = timestampWithMs() + this._idleTimeout / 1000;\n      this._startIdleTimeout(endTimestamp);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      __DEBUG_BUILD__ && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    __DEBUG_BUILD__ && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub: Hub): void {\n  const scope = hub.getScope();\n  if (scope) {\n    const transaction = scope.getTransaction();\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { makeDsn, logger, checkOrSetAlreadyCaught, isPrimitive, resolvedSyncPromise, addItemToEnvelope, createAttachmentEnvelopeItem, SyncPromise, rejectedSyncPromise, SentryError, isThenable, isPlainObject } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { setupIntegrations, setupIntegration } from './integration.js';\nimport { updateSession } from './session.js';\nimport { prepareEvent } from './utils/prepareEvent.js';\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass BaseClient {\n  /** Options passed to the SDK. */\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n  /** Array of set up integrations. */\n  __init() {\n    this._integrations = {};\n  }\n\n  /** Indicates whether this client's integrations have been set up. */\n  __init2() {\n    this._integrationsInitialized = false;\n  }\n\n  /** Number of calls being processed */\n  __init3() {\n    this._numProcessing = 0;\n  }\n\n  /** Holds flushable  */\n  __init4() {\n    this._outcomes = {};\n  }\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  constructor(options) {\n    BaseClient.prototype.__init.call(this);\n    BaseClient.prototype.__init2.call(this);\n    BaseClient.prototype.__init3.call(this);\n    BaseClient.prototype.__init4.call(this);\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url\n      });\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('No DSN provided, client will not do anything.');\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  captureException(exception, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n    let eventId = hint && hint.event_id;\n    this._process(this.eventFromException(exception, hint).then(event => this._captureEvent(event, hint, scope)).then(result => {\n      eventId = result;\n    }));\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureMessage(message,\n  // eslint-disable-next-line deprecation/deprecation\n  level, hint, scope) {\n    let eventId = hint && hint.event_id;\n    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(String(message), level, hint) : this.eventFromException(message, hint);\n    this._process(promisedEvent.then(event => this._captureEvent(event, hint, scope)).then(result => {\n      eventId = result;\n    }));\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureEvent(event, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n    let eventId = hint && hint.event_id;\n    this._process(this._captureEvent(event, hint, scope).then(result => {\n      eventId = result;\n    }));\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureSession(session) {\n    if (!this._isEnabled()) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n    if (!(typeof session.release === 'string')) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, {\n        init: false\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getOptions() {\n    return this._options;\n  }\n\n  /**\n   * @see SdkMetadata in @sentry/types\n   *\n   * @return The metadata of the SDK\n   */\n  getSdkMetadata() {\n    return this._options._metadata;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  flush(timeout) {\n    const transport = this._transport;\n    if (transport) {\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  setupIntegrations() {\n    if (this._isEnabled() && !this._integrationsInitialized) {\n      this._integrations = setupIntegrations(this._options.integrations);\n      this._integrationsInitialized = true;\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   */\n  getIntegrationById(integrationId) {\n    return this._integrations[integrationId];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIntegration(integration) {\n    try {\n      return this._integrations[integration.id] || null;\n    } catch (_oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  addIntegration(integration) {\n    setupIntegration(integration, this._integrations);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  sendEvent(event) {\n    let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this._dsn) {\n      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n      for (const attachment of hint.attachments || []) {\n        env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment, this._options.transportOptions && this._options.transportOptions.textEncoder));\n      }\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  sendSession(session) {\n    if (this._dsn) {\n      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  recordDroppedEvent(reason, category, _event) {\n    // Note: we use `event` in replay, where we overwrite this hook.\n\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Adding outcome: \"${key}\"`);\n\n      // The following works because undefined + 1 === NaN and NaN is falsy\n      this._outcomes[key] = this._outcomes[key] + 1 || 1;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n  _updateSessionFromEvent(session, event) {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n    if (exceptions) {\n      errored = true;\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && {\n          status: 'crashed'\n        }),\n        errors: session.errors || Number(errored || crashed)\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  _isClientDoneProcessing(timeout) {\n    return new SyncPromise(resolve => {\n      let ticked = 0;\n      const tick = 1;\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  _isEnabled() {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  _prepareEvent(event, hint, scope) {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations.length > 0) {\n      hint.integrations = integrations;\n    }\n    return prepareEvent(options, event, hint, scope);\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  _captureEvent(event) {\n    let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let scope = arguments.length > 2 ? arguments[2] : undefined;\n    return this._processEvent(event, hint, scope).then(finalEvent => {\n      return finalEvent.event_id;\n    }, reason => {\n      if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n        // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n        // control flow, log just the message (no stack) as a log-level log.\n        const sentryError = reason;\n        if (sentryError.logLevel === 'log') {\n          logger.log(sentryError.message);\n        } else {\n          logger.warn(sentryError);\n        }\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  _processEvent(event, hint, scope) {\n    const options = this.getOptions();\n    const {\n      sampleRate\n    } = options;\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));\n    }\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (isError && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error', event);\n      return rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`, 'log'));\n    }\n    const dataCategory = eventType === 'replay_event' ? 'replay' : eventType;\n    return this._prepareEvent(event, hint, scope).then(prepared => {\n      if (prepared === null) {\n        this.recordDroppedEvent('event_processor', dataCategory, event);\n        throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n      }\n      const isInternalException = hint.data && hint.data.__sentry__ === true;\n      if (isInternalException) {\n        return prepared;\n      }\n      const result = processBeforeSend(options, prepared, hint);\n      return _validateBeforeSendResult(result, beforeSendLabel);\n    }).then(processedEvent => {\n      if (processedEvent === null) {\n        this.recordDroppedEvent('before_send', dataCategory, event);\n        throw new SentryError(`${beforeSendLabel} returned \\`null\\`, will not send event.`, 'log');\n      }\n      const session = scope && scope.getSession();\n      if (!isTransaction && session) {\n        this._updateSessionFromEvent(session, processedEvent);\n      }\n\n      // None of the Sentry built event processor will update transaction name,\n      // so if the transaction name has been changed by an event processor, we know\n      // it has to come from custom event processor added by a user\n      const transactionInfo = processedEvent.transaction_info;\n      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n        const source = 'custom';\n        processedEvent.transaction_info = {\n          ...transactionInfo,\n          source\n        };\n      }\n      this.sendEvent(processedEvent, hint);\n      return processedEvent;\n    }).then(null, reason => {\n      if (reason instanceof SentryError) {\n        throw reason;\n      }\n      this.captureException(reason, {\n        data: {\n          __sentry__: true\n        },\n        originalException: reason\n      });\n      throw new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`);\n    });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  _process(promise) {\n    this._numProcessing++;\n    void promise.then(value => {\n      this._numProcessing--;\n      return value;\n    }, reason => {\n      this._numProcessing--;\n      return reason;\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  _sendEnvelope(envelope) {\n    if (this._transport && this._dsn) {\n      this._transport.send(envelope).then(null, reason => {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  _clearOutcomes() {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':');\n      return {\n        reason,\n        category,\n        quantity: outcomes[key]\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(event => {\n      if (!isPlainObject(event) && event !== null) {\n        throw new SentryError(invalidValueError);\n      }\n      return event;\n    }, e => {\n      throw new SentryError(`${beforeSendLabel} rejected with ${e}`);\n    });\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(options, event, hint) {\n  const {\n    beforeSend,\n    beforeSendTransaction\n  } = options;\n  if (isErrorEvent(event) && beforeSend) {\n    return beforeSend(event, hint);\n  }\n  if (isTransactionEvent(event) && beforeSendTransaction) {\n    return beforeSendTransaction(event, hint);\n  }\n  return event;\n}\nfunction isErrorEvent(event) {\n  return event.type === undefined;\n}\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\nexport { BaseClient };","map":{"version":3,"mappings":";;;;;;AA6CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA;;EAGA;;EAKA;EACAA;IAAA;EAAA;;EAEA;EACAC;IAAA;EAAA;;EAEA;EACAC;IAAA;EAAA;;EAEA;EACAC;IAAA;EAAA;;EAEA;AACA;AACA;AACA;AACA;EACAC;IAAAC;IAAAA;IAAAA;IAAAA;IACA;IACA;MACA;MACA;MACA;QACAC;QACA;QACAC;MACA;IACA;MACA;IACA;EACA;;EAEA;AACA;AACA;EACA;EACAC;IACA;IACA;MACA;MACA;IACA;IAEA;IAEA,cACA,yCACAC,sDACAA;MACAC;IACA,GACA;IAEA;EACA;;EAEA;AACA;AACA;EACAC,eACAC;EACA;EACAC,OACAC,MACAC,OACA;IACA;IAEA,6CACA,sDACA;IAEA,cACAC,cACAP,sDACAA;MACAC;IACA,GACA;IAEA;EACA;;EAEA;AACA;AACA;EACAO;IACA;IACA;MACA;MACA;IACA;IAEA;IAEA,cACA;MACAP;IACA,GACA;IAEA;EACA;;EAEA;AACA;AACA;EACAQ;IACA;MACA;MACA;IACA;IAEA;MACA;IACA;MACA;MACA;MACAC;QAAAC;MAAA;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;EACA;;EAEA;AACA;AACA;AACA;AACA;EACAC;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;IACA;MACA;QACA;MACA;IACA;MACA;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;MACA;MACA;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;MACA;MACA;IACA;EACA;;EAEA;AACA;AACA;AACA;AACA;EACAC;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;MACA;IACA;MACA;MACA;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACAC;EACA;;EAEA;AACA;AACA;EACAC;IAAA;IACA;MACA;MAEA;QACAC,wBACAA,KACAC,6BACAC,YACA,6EACA,CACA;MACA;MAEA;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;MACA;MACA;IACA;EACA;;EAEA;AACA;AACA;EACA9B;IACA;;IAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA;MACA;IACA;EACA;;EAEA;EACA+B;IACA;IACA;IACA;IAEA;MACAC;MAEA;QACA;QACA;UACAC;UACA;QACA;MACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IAEA;MACApB;QACA;UAAAqB;QAAA;QACAC;MACA;MACA;IACA;EACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAC;IACA;MACA;MACA;MAEA;QACA;UACAC;UACAC;QACA;UACAC;UACA;YACAF;YACAC;UACA;QACA;MACA;IACA;EACA;;EAEA;EACAE;IACA;EACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAC;IACA;IACA;IACA;MACAjC;IACA;IACA;EACA;;EAEA;AACA;AACA;AACA;AACA;AACA;EACAkC;IAAA;IAAA;IACA,mDACAC;MACA;IACA,GACAC;MACA;QACA;QACA;QACA;QACA;UACAC;QACA;UACAA;QACA;MACA;MACA;IACA,EACA;EACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAC;IACA;IACA;MAAAC;IAAA;IAEA;MACA;IACA;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;MACA;MACA,2BACA,gBACA,mGACA,MACA,CACA;IACA;IAEA;IAEA,8CACA5C;MACA;QACA;QACA;MACA;MAEA;MACA;QACA;MACA;MAEA;MACA;IACA,GACAA;MACA;QACA;QACA;MACA;MAEA;MACA;QACA;MACA;;MAEA;MACA;MACA;MACA;MACA;QACA;QACA6C;UACA;UACAC;QACA;MACA;MAEA;MACA;IACA,GACA9C;MACA;QACA;MACA;MAEA;QACA+C;UACAC;QACA;QACAC;MACA;MACA,sBACA,uIACA;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;IACA,kBACAC;MACA;MACA;IACA,GACAV;MACA;MACA;IACA,EACA;EACA;;EAEA;AACA;AACA;EACAW;IACA;MACA;QACA;MACA;IACA;MACA;IACA;EACA;;EAEA;AACA;AACA;EACAC;IACA;IACA;IACA;MACA;MACA;QACAZ;QACAa;QACAC;MACA;IACA;EACA;;EAEA;AACA;AACA;EACA;AAYA;;AAEA;AACA;AACA;AACA,mCACAC,kBACAC,iBACA;EACA;EACA;IACA,6BACAC;MACA;QACA;MACA;MACA;IACA,GACAC;MACA;IACA,EACA;EACA;IACA;EACA;EACA;AACA;;AAEA;AACA;AACA;AACA,2BACAC,SACAF,OACArD,MACA;EACA;IAAAwD;IAAAC;EAAA;EAEA;IACA;EACA;EAEA;IACA;EACA;EAEA;AACA;AAEA;EACA;AACA;AAEA;EACA;AACA","names":["__init","__init2","__init3","__init4","constructor","BaseClient","recordDroppedEvent","url","captureException","then","eventId","captureMessage","message","level","hint","scope","promisedEvent","captureEvent","captureSession","updateSession","init","getDsn","getOptions","getSdkMetadata","getTransport","flush","close","setupIntegrations","getIntegrationById","getIntegration","addIntegration","setupIntegration","sendEvent","env","createAttachmentEnvelopeItem","attachment","sendSession","_updateSessionFromEvent","errored","crashed","status","errors","_isClientDoneProcessing","clearInterval","resolve","ticked","_isEnabled","_prepareEvent","_captureEvent","finalEvent","reason","logger","_processEvent","sampleRate","processedEvent","source","data","__sentry__","originalException","_process","value","_sendEnvelope","_clearOutcomes","category","quantity","beforeSendResult","beforeSendLabel","event","e","options","beforeSend","beforeSendTransaction"],"sources":["/Users/rajeshbagul/code/ai-hackathon/node_modules/@sentry/src/baseclient.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type {\n  Client,\n  ClientOptions,\n  DataCategory,\n  DsnComponents,\n  Envelope,\n  ErrorEvent,\n  Event,\n  EventDropReason,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  Outcome,\n  SdkMetadata,\n  Session,\n  SessionAggregates,\n  Severity,\n  SeverityLevel,\n  TransactionEvent,\n  Transport,\n} from '@sentry/types';\nimport {\n  addItemToEnvelope,\n  checkOrSetAlreadyCaught,\n  createAttachmentEnvelopeItem,\n  isPlainObject,\n  isPrimitive,\n  isThenable,\n  logger,\n  makeDsn,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  SentryError,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope';\nimport type { IntegrationIndex } from './integration';\nimport { setupIntegration, setupIntegrations } from './integration';\nimport type { Scope } from './scope';\nimport { updateSession } from './session';\nimport { prepareEvent } from './utils/prepareEvent';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<O extends ClientOptions> implements Client<O> {\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  protected readonly _transport?: Transport;\n\n  /** Array of set up integrations. */\n  protected _integrations: IntegrationIndex = {};\n\n  /** Indicates whether this client's integrations have been set up. */\n  protected _integrationsInitialized: boolean = false;\n\n  /** Number of calls being processed */\n  protected _numProcessing: number = 0;\n\n  /** Holds flushable  */\n  private _outcomes: { [key: string]: number } = {};\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  protected constructor(options: O) {\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    } else {\n      __DEBUG_BUILD__ && logger.warn('No DSN provided, client will not do anything.');\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      __DEBUG_BUILD__ && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this.eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(\n    message: string,\n    // eslint-disable-next-line deprecation/deprecation\n    level?: Severity | SeverityLevel,\n    hint?: EventHint,\n    scope?: Scope,\n  ): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(String(message), level, hint)\n      : this.eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      __DEBUG_BUILD__ && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(session: Session): void {\n    if (!this._isEnabled()) {\n      __DEBUG_BUILD__ && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      __DEBUG_BUILD__ && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, { init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @see SdkMetadata in @sentry/types\n   *\n   * @return The metadata of the SDK\n   */\n  public getSdkMetadata(): SdkMetadata | undefined {\n    return this._options._metadata;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport | undefined {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    const transport = this._transport;\n    if (transport) {\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  public setupIntegrations(): void {\n    if (this._isEnabled() && !this._integrationsInitialized) {\n      this._integrations = setupIntegrations(this._options.integrations);\n      this._integrationsInitialized = true;\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   */\n  public getIntegrationById(integrationId: string): Integration | undefined {\n    return this._integrations[integrationId];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      __DEBUG_BUILD__ && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addIntegration(integration: Integration): void {\n    setupIntegration(integration, this._integrations);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event, hint: EventHint = {}): void {\n    if (this._dsn) {\n      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n      for (const attachment of hint.attachments || []) {\n        env = addItemToEnvelope(\n          env,\n          createAttachmentEnvelopeItem(\n            attachment,\n            this._options.transportOptions && this._options.transportOptions.textEncoder,\n          ),\n        );\n      }\n\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session | SessionAggregates): void {\n    if (this._dsn) {\n      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public recordDroppedEvent(reason: EventDropReason, category: DataCategory, _event?: Event): void {\n    // Note: we use `event` in replay, where we overwrite this hook.\n\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      __DEBUG_BUILD__ && logger.log(`Adding outcome: \"${key}\"`);\n\n      // The following works because undefined + 1 === NaN and NaN is falsy\n      this._outcomes[key] = this._outcomes[key] + 1 || 1;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, hint: EventHint, scope?: Scope): PromiseLike<Event | null> {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations.length > 0) {\n      hint.integrations = integrations;\n    }\n    return prepareEvent(options, event, hint, scope);\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(event: Event, hint: EventHint = {}, scope?: Scope): PromiseLike<string | undefined> {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (__DEBUG_BUILD__) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          const sentryError = reason as SentryError;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint: EventHint, scope?: Scope): PromiseLike<Event> {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));\n    }\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (isError && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error', event);\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n          'log',\n        ),\n      );\n    }\n\n    const dataCategory: DataCategory = eventType === 'replay_event' ? 'replay' : eventType;\n\n    return this._prepareEvent(event, hint, scope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory, event);\n          throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n        }\n\n        const isInternalException = hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory, event);\n          throw new SentryError(`${beforeSendLabel} returned \\`null\\`, will not send event.`, 'log');\n        }\n\n        const session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason as Error,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected _sendEnvelope(envelope: Envelope): void {\n    if (this._transport && this._dsn) {\n      this._transport.send(envelope).then(null, reason => {\n        __DEBUG_BUILD__ && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      __DEBUG_BUILD__ && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  protected _clearOutcomes(): Outcome[] {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':') as [EventDropReason, DataCategory];\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public abstract eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event>;\n\n  /**\n   * @inheritDoc\n   */\n  public abstract eventFromMessage(\n    _message: string,\n    // eslint-disable-next-line deprecation/deprecation\n    _level?: Severity | SeverityLevel,\n    _hint?: EventHint,\n  ): PromiseLike<Event>;\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult: PromiseLike<Event | null> | Event | null,\n  beforeSendLabel: string,\n): PromiseLike<Event | null> | Event | null {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw new SentryError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n): PromiseLike<Event | null> | Event | null {\n  const { beforeSend, beforeSendTransaction } = options;\n\n  if (isErrorEvent(event) && beforeSend) {\n    return beforeSend(event, hint);\n  }\n\n  if (isTransactionEvent(event) && beforeSendTransaction) {\n    return beforeSendTransaction(event, hint);\n  }\n\n  return event;\n}\n\nfunction isErrorEvent(event: Event): event is ErrorEvent {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event: Event): event is TransactionEvent {\n  return event.type === 'transaction';\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}